/**
 * FutureDMS API
 * Premier Enterprise Dealership Management System
 *
 * OpenAPI spec version: 0.3.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class ServiceApi {
    protected basePath = 'https://api.futuredms.com/v1';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Removes a service ticket at the given id
     * 
     * @param customerId the id of a customer
     */
    public customerCustomerIdDelete(customerId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.customerCustomerIdDeleteWithHttpInfo(customerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     */
    public jobOperationCategoryGet(extraHttpRequestParams?: any): Observable<Array<models.JobOperationCategory>> {
        return this.jobOperationCategoryGetWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param jobOperationCategoryId the id of a job operation category
     */
    public jobOperationCategoryJobOperationCategoryIdGet(jobOperationCategoryId: string, extraHttpRequestParams?: any): Observable<models.JobOperationCategory> {
        return this.jobOperationCategoryJobOperationCategoryIdGetWithHttpInfo(jobOperationCategoryId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param jobOperationCategoryId the id of a job operation category
     */
    public jobOperationCategoryJobOperationCategoryIdJobGet(jobOperationCategoryId: string, extraHttpRequestParams?: any): Observable<Array<models.JobOperationCategory>> {
        return this.jobOperationCategoryJobOperationCategoryIdJobGetWithHttpInfo(jobOperationCategoryId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * a service ticket tracks the activities between a customer, the service department.
     * A service ticket endpoint returns service tickets related to the logged in user 
     */
    public serviceTicketGet(extraHttpRequestParams?: any): Observable<Array<models.ServiceTicket>> {
        return this.serviceTicketGetWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * A service ticket associated service advisor
     * Retrieves the service advisor resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdAdvisorGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<models.ServiceTicketAdvisor> {
        return this.serviceTicketServiceTicketIdAdvisorGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The charges associated with a service ticket
     * Service tickets generate charges for parts and labor during their lifecycle
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdChargesGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceTicketCharge>> {
        return this.serviceTicketServiceTicketIdChargesGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Removes a service ticket charge with the given id
     * 
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketChargeId The id of the charge to remove from the service ticket
     */
    public serviceTicketServiceTicketIdChargesServiceTicketChargeIdDelete(serviceTicketId: string, serviceTicketChargeId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdChargesServiceTicketChargeIdDeleteWithHttpInfo(serviceTicketId, serviceTicketChargeId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Puts a charge in a service ticket
     * Adds or updates a part in a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketChargeId The id of the request to add a charge to the service ticket
     * @param addServiceTicketChargeRequest Command to add a charge to a service ticket
     */
    public serviceTicketServiceTicketIdChargesServiceTicketChargeIdPut(serviceTicketId: string, serviceTicketChargeId: string, addServiceTicketChargeRequest?: models.Charge, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdChargesServiceTicketChargeIdPutWithHttpInfo(serviceTicketId, serviceTicketChargeId, addServiceTicketChargeRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * A service ticket associated customer
     * Retrieves the customer resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdCustomerGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceTicketCustomer>> {
        return this.serviceTicketServiceTicketIdCustomerGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Removes a service ticket at the given id
     * 
     * @param serviceTicketId the id of a service ticket
     */
    public serviceTicketServiceTicketIdDelete(serviceTicketId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdDeleteWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * A service ticket associated service advisor
     * Retrieves the service advisor resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdForemanGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<models.ServiceTicketForeman> {
        return this.serviceTicketServiceTicketIdForemanGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Gets a service ticket
     * The service ticket allows appointments and jobs related to a vehicle to be tracked 
     * @param serviceTicketId the id of a service ticket.
     */
    public serviceTicketServiceTicketIdGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<models.ServiceTicket> {
        return this.serviceTicketServiceTicketIdGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Time Estimates
     * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdJobsGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceTicketJob>> {
        return this.serviceTicketServiceTicketIdJobsGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * remove a job from a service ticket
     * Remove a job from a service ticket designated by the given serviceTicketJobId
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketJobId The id of the association between a service ticket and a job
     */
    public serviceTicketServiceTicketIdJobsServiceTicketJobIdDelete(serviceTicketId: string, serviceTicketJobId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdJobsServiceTicketJobIdDeleteWithHttpInfo(serviceTicketId, serviceTicketJobId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Add or Replace a job with a new one
     * A service advisor can add jobs to a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketJobId The id of the association between a service ticket and a job
     * @param jobId The id of the job to be associated with the service ticket
     */
    public serviceTicketServiceTicketIdJobsServiceTicketJobIdPut(serviceTicketId: string, serviceTicketJobId: string, jobId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdJobsServiceTicketJobIdPutWithHttpInfo(serviceTicketId, serviceTicketJobId, jobId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The parts for jobs in a service ticket
     * Returns a list of parts for all the jobs in a service ticket
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdPartsGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceTicketPart>> {
        return this.serviceTicketServiceTicketIdPartsGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Removes a service ticket part at the given id
     * 
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The id of the request to add a part to the service ticket
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdDelete(serviceTicketId: string, serviceTicketPartId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdPartsServiceTicketPartIdDeleteWithHttpInfo(serviceTicketId, serviceTicketPartId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Puts a part in a service ticket
     * Adds or updates a part in a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The id of the request to add a part to the service ticket
     * @param partId 
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdPut(serviceTicketId: string, serviceTicketPartId: string, partId?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdPartsServiceTicketPartIdPutWithHttpInfo(serviceTicketId, serviceTicketPartId, partId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Status
     * The status of a parts request
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The associated part id in a service ticket
     * @param statusId The status id of a part
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPut(serviceTicketId: string, serviceTicketPartId: string, statusId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPutWithHttpInfo(serviceTicketId, serviceTicketPartId, statusId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Places or replaces a service ticket at the given id
     * Adds a service ticket for a given id  
     * @param serviceTicketId the id of a service ticket
     */
    public serviceTicketServiceTicketIdPut(serviceTicketId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdPutWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Replace the current status with a new one.
     * The status of a service ticket corresponds to it&#39;s workflow state.  State transitions are governed by the rules requiring certain preconditions.
     * @param serviceTicketId The associated service ticket id
     * @param workflow The current workflow status name
     */
    public serviceTicketServiceTicketIdStatusPut(serviceTicketId: string, workflow: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceTicketServiceTicketIdStatusPutWithHttpInfo(serviceTicketId, workflow, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * A service ticket associated technician
     * Retrieves the technician associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdTechnicianGet(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceTicketTechnician>> {
        return this.serviceTicketServiceTicketIdTechnicianGetWithHttpInfo(serviceTicketId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Removes a service ticket at the given id
     * 
     * @param customerId the id of a customer
     */
    public customerCustomerIdDeleteWithHttpInfo(customerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/customer/${customerId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling customerCustomerIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     */
    public jobOperationCategoryGetWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/job-operation-category`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobOperationCategoryId the id of a job operation category
     */
    public jobOperationCategoryJobOperationCategoryIdGetWithHttpInfo(jobOperationCategoryId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/job-operation-category/${jobOperationCategoryId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobOperationCategoryId' is not null or undefined
        if (jobOperationCategoryId === null || jobOperationCategoryId === undefined) {
            throw new Error('Required parameter jobOperationCategoryId was null or undefined when calling jobOperationCategoryJobOperationCategoryIdGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobOperationCategoryId the id of a job operation category
     */
    public jobOperationCategoryJobOperationCategoryIdJobGetWithHttpInfo(jobOperationCategoryId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/job-operation-category/${jobOperationCategoryId}/job`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobOperationCategoryId' is not null or undefined
        if (jobOperationCategoryId === null || jobOperationCategoryId === undefined) {
            throw new Error('Required parameter jobOperationCategoryId was null or undefined when calling jobOperationCategoryJobOperationCategoryIdJobGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * a service ticket tracks the activities between a customer, the service department.
     * A service ticket endpoint returns service tickets related to the logged in user 
     */
    public serviceTicketGetWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * A service ticket associated service advisor
     * Retrieves the service advisor resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdAdvisorGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/advisor`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdAdvisorGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The charges associated with a service ticket
     * Service tickets generate charges for parts and labor during their lifecycle
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdChargesGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/charges`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdChargesGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Removes a service ticket charge with the given id
     * 
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketChargeId The id of the charge to remove from the service ticket
     */
    public serviceTicketServiceTicketIdChargesServiceTicketChargeIdDeleteWithHttpInfo(serviceTicketId: string, serviceTicketChargeId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/charges/${serviceTicketChargeId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdChargesServiceTicketChargeIdDelete.');
        }
        // verify required parameter 'serviceTicketChargeId' is not null or undefined
        if (serviceTicketChargeId === null || serviceTicketChargeId === undefined) {
            throw new Error('Required parameter serviceTicketChargeId was null or undefined when calling serviceTicketServiceTicketIdChargesServiceTicketChargeIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Puts a charge in a service ticket
     * Adds or updates a part in a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketChargeId The id of the request to add a charge to the service ticket
     * @param addServiceTicketChargeRequest Command to add a charge to a service ticket
     */
    public serviceTicketServiceTicketIdChargesServiceTicketChargeIdPutWithHttpInfo(serviceTicketId: string, serviceTicketChargeId: string, addServiceTicketChargeRequest?: models.Charge, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/charges/${serviceTicketChargeId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdChargesServiceTicketChargeIdPut.');
        }
        // verify required parameter 'serviceTicketChargeId' is not null or undefined
        if (serviceTicketChargeId === null || serviceTicketChargeId === undefined) {
            throw new Error('Required parameter serviceTicketChargeId was null or undefined when calling serviceTicketServiceTicketIdChargesServiceTicketChargeIdPut.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: addServiceTicketChargeRequest == null ? '' : JSON.stringify(addServiceTicketChargeRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * A service ticket associated customer
     * Retrieves the customer resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdCustomerGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/customer`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdCustomerGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Removes a service ticket at the given id
     * 
     * @param serviceTicketId the id of a service ticket
     */
    public serviceTicketServiceTicketIdDeleteWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * A service ticket associated service advisor
     * Retrieves the service advisor resource associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdForemanGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/foreman`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdForemanGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Gets a service ticket
     * The service ticket allows appointments and jobs related to a vehicle to be tracked 
     * @param serviceTicketId the id of a service ticket.
     */
    public serviceTicketServiceTicketIdGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Time Estimates
     * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdJobsGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/jobs`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdJobsGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * remove a job from a service ticket
     * Remove a job from a service ticket designated by the given serviceTicketJobId
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketJobId The id of the association between a service ticket and a job
     */
    public serviceTicketServiceTicketIdJobsServiceTicketJobIdDeleteWithHttpInfo(serviceTicketId: string, serviceTicketJobId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/jobs/${serviceTicketJobId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdJobsServiceTicketJobIdDelete.');
        }
        // verify required parameter 'serviceTicketJobId' is not null or undefined
        if (serviceTicketJobId === null || serviceTicketJobId === undefined) {
            throw new Error('Required parameter serviceTicketJobId was null or undefined when calling serviceTicketServiceTicketIdJobsServiceTicketJobIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Add or Replace a job with a new one
     * A service advisor can add jobs to a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketJobId The id of the association between a service ticket and a job
     * @param jobId The id of the job to be associated with the service ticket
     */
    public serviceTicketServiceTicketIdJobsServiceTicketJobIdPutWithHttpInfo(serviceTicketId: string, serviceTicketJobId: string, jobId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/jobs/${serviceTicketJobId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdJobsServiceTicketJobIdPut.');
        }
        // verify required parameter 'serviceTicketJobId' is not null or undefined
        if (serviceTicketJobId === null || serviceTicketJobId === undefined) {
            throw new Error('Required parameter serviceTicketJobId was null or undefined when calling serviceTicketServiceTicketIdJobsServiceTicketJobIdPut.');
        }
        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling serviceTicketServiceTicketIdJobsServiceTicketJobIdPut.');
        }
        if (jobId !== undefined) {
            if(jobId instanceof Date) {
                queryParameters.set('jobId', <any>jobId.d.toISOString());
            } else {
                queryParameters.set('jobId', <any>jobId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The parts for jobs in a service ticket
     * Returns a list of parts for all the jobs in a service ticket
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdPartsGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/parts`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdPartsGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Removes a service ticket part at the given id
     * 
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The id of the request to add a part to the service ticket
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdDeleteWithHttpInfo(serviceTicketId: string, serviceTicketPartId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/parts/${serviceTicketPartId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdDelete.');
        }
        // verify required parameter 'serviceTicketPartId' is not null or undefined
        if (serviceTicketPartId === null || serviceTicketPartId === undefined) {
            throw new Error('Required parameter serviceTicketPartId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Puts a part in a service ticket
     * Adds or updates a part in a service ticket
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The id of the request to add a part to the service ticket
     * @param partId 
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdPutWithHttpInfo(serviceTicketId: string, serviceTicketPartId: string, partId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/parts/${serviceTicketPartId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdPut.');
        }
        // verify required parameter 'serviceTicketPartId' is not null or undefined
        if (serviceTicketPartId === null || serviceTicketPartId === undefined) {
            throw new Error('Required parameter serviceTicketPartId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdPut.');
        }
        if (partId !== undefined) {
            if(partId instanceof Date) {
                queryParameters.set('partId', <any>partId.d.toISOString());
            } else {
                queryParameters.set('partId', <any>partId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Status
     * The status of a parts request
     * @param serviceTicketId The associated service ticket id
     * @param serviceTicketPartId The associated part id in a service ticket
     * @param statusId The status id of a part
     */
    public serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPutWithHttpInfo(serviceTicketId: string, serviceTicketPartId: string, statusId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/parts/${serviceTicketPartId}/status`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPut.');
        }
        // verify required parameter 'serviceTicketPartId' is not null or undefined
        if (serviceTicketPartId === null || serviceTicketPartId === undefined) {
            throw new Error('Required parameter serviceTicketPartId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPut.');
        }
        // verify required parameter 'statusId' is not null or undefined
        if (statusId === null || statusId === undefined) {
            throw new Error('Required parameter statusId was null or undefined when calling serviceTicketServiceTicketIdPartsServiceTicketPartIdStatusPut.');
        }
        if (statusId !== undefined) {
            if(statusId instanceof Date) {
                queryParameters.set('statusId', <any>statusId.d.toISOString());
            } else {
                queryParameters.set('statusId', <any>statusId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Places or replaces a service ticket at the given id
     * Adds a service ticket for a given id  
     * @param serviceTicketId the id of a service ticket
     */
    public serviceTicketServiceTicketIdPutWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdPut.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Replace the current status with a new one.
     * The status of a service ticket corresponds to it&#39;s workflow state.  State transitions are governed by the rules requiring certain preconditions.
     * @param serviceTicketId The associated service ticket id
     * @param workflow The current workflow status name
     */
    public serviceTicketServiceTicketIdStatusPutWithHttpInfo(serviceTicketId: string, workflow: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/status`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdStatusPut.');
        }
        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling serviceTicketServiceTicketIdStatusPut.');
        }
        if (workflow !== undefined) {
            if(workflow instanceof Date) {
                queryParameters.set('workflow', <any>workflow.d.toISOString());
            } else {
                queryParameters.set('workflow', <any>workflow);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * A service ticket associated technician
     * Retrieves the technician associated with a service ticket.
     * @param serviceTicketId The associated service ticket id
     */
    public serviceTicketServiceTicketIdTechnicianGetWithHttpInfo(serviceTicketId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-ticket/${serviceTicketId}/technician`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceTicketId' is not null or undefined
        if (serviceTicketId === null || serviceTicketId === undefined) {
            throw new Error('Required parameter serviceTicketId was null or undefined when calling serviceTicketServiceTicketIdTechnicianGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
